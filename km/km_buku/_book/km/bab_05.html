<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>6&nbsp; BAB 5: MENGHUBUNGKAN LOGIKA KOGNITIF DENGAN DUNIA FISIK – Peta Pengetahuan Untuk Rekayasa Sistem Cerdas</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-ca0a5195ee179662b007c6f17db91e5c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-sidebar quarto-light">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#model-kontrol-fisik-menggabungkan-siberetika-dan-termodinamika" id="toc-model-kontrol-fisik-menggabungkan-siberetika-dan-termodinamika" class="nav-link active" data-scroll-target="#model-kontrol-fisik-menggabungkan-siberetika-dan-termodinamika"><span class="header-section-number">6.1</span> 5.1 Model Kontrol-Fisik: Menggabungkan Siberetika dan Termodinamika</a></li>
  <li><a href="#tiga-lensa-pemetaan-sistem-cerdas-secara-utuh" id="toc-tiga-lensa-pemetaan-sistem-cerdas-secara-utuh" class="nav-link" data-scroll-target="#tiga-lensa-pemetaan-sistem-cerdas-secara-utuh"><span class="header-section-number">6.2</span> 5.2 Tiga Lensa Pemetaan Sistem Cerdas Secara Utuh</a></li>
  <li><a href="#pengetahuan-dalam-model-integrasi-akurasi-peta-strategi-relatif-terhadap-realitas-peta-efisiensi" id="toc-pengetahuan-dalam-model-integrasi-akurasi-peta-strategi-relatif-terhadap-realitas-peta-efisiensi" class="nav-link" data-scroll-target="#pengetahuan-dalam-model-integrasi-akurasi-peta-strategi-relatif-terhadap-realitas-peta-efisiensi"><span class="header-section-number">6.3</span> 5.3 Pengetahuan dalam Model Integrasi: Akurasi Peta Strategi relatif terhadap realitas Peta Efisiensi</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title"><strong>BAB 5: MENGHUBUNGKAN LOGIKA KOGNITIF DENGAN DUNIA FISIK</strong></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Bab ini membahas bagaimana siklus kognitif (PUDAL) yang telah diformalkan menjadi aturan yang dapat dieksekusi (ABCD) diintegrasikan dengan mesin fisik yang menjalankan pekerjaan yang sesungguhnya. Untuk merekayasa sistem cerdas secara utuh, kita harus memetakan tidak hanya logikanya, tetapi juga fisika di mana logika itu beroperasi.</p>
<hr>
<section id="model-kontrol-fisik-menggabungkan-siberetika-dan-termodinamika" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="model-kontrol-fisik-menggabungkan-siberetika-dan-termodinamika"><span class="header-section-number">6.1</span> 5.1 Model Kontrol-Fisik: Menggabungkan Siberetika dan Termodinamika</h2>
<p>Sistem cerdas yang didefinisikan dalam buku ini adalah arsitektur canggih yang secara efektif menggabungkan dua bidang ilmu utama: <strong>Siberetika</strong> (unit kontrol PUDAL) dan <strong>Termodinamika</strong> (Mesin Transformasi yang melakukan kerja),.</p>
<p>Model Kontrol-Fisik ini memisahkan sistem menjadi dua blok yang berbeda namun terhubung:</p>
<ol type="1">
<li><strong>Kontroler (Siklus PUDAL):</strong> Ini adalah lapisan kognitif atau “pikiran” sistem. Tugasnya adalah memproses pengetahuan, merancang rencana (fase <strong>[D]</strong>), dan menghasilkan sinyal kontrol.</li>
<li><strong>Plant/Mesin Transformasi (<em>Transformation Engine</em>):</strong> Ini adalah lapisan fisik atau “tubuh” yang melakukan pekerjaan di dunia nyata,. Mesin ini mengubah energi sumber menjadi kerja (misalnya, memindahkan beban dari Keadaan A ke Keadaan B).</li>
</ol>
<p><strong>Aliran Pengetahuan dalam Model Kontrol-Fisik:</strong> * <strong>Aliran Umpan Maju (<em>Feed-forward</em>):</strong> Kontroler PUDAL mengirimkan <strong>Sinyal Kontrol</strong> ke Mesin Transformasi. Sinyal ini merepresentasikan fase <strong>Tindakan [A]</strong> atau perintah eksekusi,. * <strong>Aliran Umpan Balik (<em>Feedback</em>):</strong> Mesin Transformasi mengembalikan <strong>Data Sensor</strong> ke Kontroler PUDAL. Data ini merupakan sinyal kesalahan atau hasil nyata, yang memicu fase <strong>Persepsi [P]</strong> dalam siklus kognitif,.</p>
<p>Dalam model terintegrasi ini, pengetahuan direpresentasikan sebagai hubungan adaptif antara perintah yang dikirim (logika) dan hasil yang dicapai (fisika),.</p>
<p><strong>Usulan Gambar 5.1: Diagram Blok Siberetika dan Mesin Transformasi</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Placeholder Gambar</th>
<th style="text-align: left;">Caption</th>
<th style="text-align: left;">Sumber</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Gambar 5.1</strong></td>
<td style="text-align: left;">Diagram blok dua kotak yang menampilkan <strong>Kontroler (Siklus PUDAL)</strong> di sebelah kiri dan <strong>Mesin Transformasi (Plant)</strong> di sebelah kanan, dihubungkan oleh panah dua arah: <strong>Sinyal Kontrol</strong> (Action [A]) menuju Plant, dan <strong>Data Sensor</strong> (Persepsi [P]) kembali ke Kontroler, menggambarkan fondasi arsitektur siber-fisik.</td>
<td style="text-align: left;">,</td>
</tr>
</tbody>
</table>
</section>
<section id="tiga-lensa-pemetaan-sistem-cerdas-secara-utuh" class="level2" data-number="6.2">
<h2 data-number="6.2" class="anchored" data-anchor-id="tiga-lensa-pemetaan-sistem-cerdas-secara-utuh"><span class="header-section-number">6.2</span> 5.2 Tiga Lensa Pemetaan Sistem Cerdas Secara Utuh</h2>
<p>Peta konsep statis yang umum tidak lagi memadai untuk memodelkan sistem yang menyatukan logika kognitif dan termodinamika fisik. Untuk memahami sistem secara menyeluruh, kita harus menggunakan tiga peta dinamis yang berfungsi sebagai lensa untuk merepresentasikan Arsitektur, Efisiensi, dan Strategi,:</p>
<p><strong>Tabel 5.1: Tiga Lensa Pemetaan Dinamis untuk Sistem Cerdas</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Peta Dinamis</th>
<th style="text-align: left;">Fokus Utama (Pertanyaan Kunci)</th>
<th style="text-align: left;">Struktur</th>
<th style="text-align: left;">Tujuan Pemodelan</th>
<th style="text-align: left;">Sumber</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Peta Arsitektur</strong> (<em>Cybernetic Block Diagram</em>)</td>
<td style="text-align: left;">Siapa yang mengendalikan?,</td>
<td style="text-align: left;">Diagram Blok (Kontroler dan Plant)</td>
<td style="text-align: left;">Mendefinisikan pemisahan fungsional dan aliran kontrol antara unit PUDAL dan unit fisik,.</td>
<td style="text-align: left;">,</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Peta Efisiensi</strong> (<em>Bond Graph</em>)</td>
<td style="text-align: left;">Bagaimana energi digunakan?,</td>
<td style="text-align: left;">Graf Ikatan (Node dan Bonds)</td>
<td style="text-align: left;">Memodelkan bagaimana daya dikonversi di dalam Mesin Transformasi. Ini memvisualisasikan ketidakefisienan dan kehilangan energi dalam sistem fisik,.</td>
<td style="text-align: left;">,,</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Peta Strategi</strong> (<em>State-Space Landscape</em>)</td>
<td style="text-align: left;">Ke mana kita akan pergi?,</td>
<td style="text-align: left;">Lanskap Topologi (Graf multi-dimensi)</td>
<td style="text-align: left;">Memodelkan rencana kognitif. Kontroler menggunakannya untuk menghitung jalur resistansi terendah dari Titik A (Posisi saat ini) ke Titik B (Posisi yang diinginkan).</td>
<td style="text-align: left;">,</td>
</tr>
</tbody>
</table>
<p>Peta Efisiensi (Bond Graph) secara ilmiah relevan karena memperlakukan pengetahuan sebagai kuantitas fisik yang berhubungan dengan konversi daya. Jika unit PUDAL mempersepsikan [P] bahwa mesin terlalu panas (membuang energi), peta ini membantu memetakan lokasi kehilangan energi tersebut. Sementara itu, Peta Strategi digunakan oleh fase Keputusan [D] PUDAL untuk menganalisis lanskap (hambatan atau biaya energi) dan menghitung rencana tindakan yang paling efisien.</p>
<p><strong>Usulan Gambar 5.2: Tiga Lensa Pemetaan Sistem Cerdas</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Placeholder Gambar</th>
<th style="text-align: left;">Caption</th>
<th style="text-align: left;">Sumber</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Gambar 5.2</strong></td>
<td style="text-align: left;">Tiga citra berdampingan yang menunjukkan (A) Diagram Blok Siberetika (Peta Arsitektur), (B) Jaringan Bond Graph (Peta Efisiensi) yang memperlihatkan aliran dan konversi energi, dan (C) Peta Topologi Ruang Keadaan (Peta Strategi) yang menunjukkan jalur yang direncanakan dari Titik A ke Titik B melewati rintangan.</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</section>
<section id="pengetahuan-dalam-model-integrasi-akurasi-peta-strategi-relatif-terhadap-realitas-peta-efisiensi" class="level2" data-number="6.3">
<h2 data-number="6.3" class="anchored" data-anchor-id="pengetahuan-dalam-model-integrasi-akurasi-peta-strategi-relatif-terhadap-realitas-peta-efisiensi"><span class="header-section-number">6.3</span> 5.3 Pengetahuan dalam Model Integrasi: Akurasi Peta Strategi relatif terhadap realitas Peta Efisiensi</h2>
<p>Ketiga peta dinamis ini berfungsi sebagai lapisan-lapisan dari satu model yang terpadu,.</p>
<p><strong>Peta Strategi</strong> mewakili model mental sistem, atau hipotesis tentang bagaimana mencapai tujuan (jalur resistansi terendah),. Peta ini sepenuhnya dienkapsulasi di dalam Kontroler PUDAL,. Di sisi lain, <strong>Peta Efisiensi</strong> secara fisik memodelkan realitas yang terjadi di dalam Mesin Transformasi (Plant), menunjukkan bagaimana energi diubah menjadi kerja,.</p>
<p>Dalam model terpadu ini, <strong>Pengetahuan</strong> didefinisikan sebagai <strong>akurasi Peta Strategi</strong> relatif terhadap <strong>realitas yang dimodelkan oleh Peta Efisiensi</strong>,. Dengan kata lain, pengetahuan adalah seberapa akurat rencana yang dihitung oleh Kontroler (logika PUDAL) sesuai dengan hukum fisika dan konversi energi yang terjadi di Mesin Transformasi. Peta pengetahuan yang sempurna adalah peta yang memiliki model mental (Strategi) yang sepenuhnya sesuai dengan dunia fisik (Efisiensi).</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>