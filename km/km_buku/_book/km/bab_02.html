<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>3&nbsp; BAB 2: MEMETAKAN KEDALAMAN KOGNITIF DENGAN TAKSONOMI BLOOM – Peta Pengetahuan Untuk Rekayasa Sistem Cerdas</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-ca0a5195ee179662b007c6f17db91e5c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-sidebar quarto-light">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#taksonomi-bloom-enam-tingkat-kedalaman-kognitif" id="toc-taksonomi-bloom-enam-tingkat-kedalaman-kognitif" class="nav-link active" data-scroll-target="#taksonomi-bloom-enam-tingkat-kedalaman-kognitif"><span class="header-section-number">3.1</span> 2.1 Taksonomi Bloom: Enam Tingkat Kedalaman Kognitif</a></li>
  <li><a href="#struktur-peta-untuk-merepresentasikan-kedalaman" id="toc-struktur-peta-untuk-merepresentasikan-kedalaman" class="nav-link" data-scroll-target="#struktur-peta-untuk-merepresentasikan-kedalaman"><span class="header-section-number">3.2</span> 2.2 Struktur Peta untuk Merepresentasikan Kedalaman</a></li>
  <li><a href="#menerjemahkan-tingkat-kognitif-menjadi-elemen-peta" id="toc-menerjemahkan-tingkat-kognitif-menjadi-elemen-peta" class="nav-link" data-scroll-target="#menerjemahkan-tingkat-kognitif-menjadi-elemen-peta"><span class="header-section-number">3.3</span> 2.3 Menerjemahkan Tingkat Kognitif menjadi Elemen Peta</a></li>
  <li><a href="#metafora-visual-untuk-kedalaman-pohon-pengetahuan-dan-bawang" id="toc-metafora-visual-untuk-kedalaman-pohon-pengetahuan-dan-bawang" class="nav-link" data-scroll-target="#metafora-visual-untuk-kedalaman-pohon-pengetahuan-dan-bawang"><span class="header-section-number">3.4</span> 2.4 Metafora Visual untuk Kedalaman: Pohon Pengetahuan dan Bawang</a>
  <ul class="collapse">
  <li><a href="#a.-pohon-pengetahuan-hierarki-vertikal" id="toc-a.-pohon-pengetahuan-hierarki-vertikal" class="nav-link" data-scroll-target="#a.-pohon-pengetahuan-hierarki-vertikal"><span class="header-section-number">3.4.1</span> A. Pohon Pengetahuan (Hierarki Vertikal)</a></li>
  <li><a href="#b.-bawang-peta-konsentris" id="toc-b.-bawang-peta-konsentris" class="nav-link" data-scroll-target="#b.-bawang-peta-konsentris"><span class="header-section-number">3.4.2</span> B. Bawang (Peta Konsentris)</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title"><strong>BAB 2: MEMETAKAN KEDALAMAN KOGNITIF DENGAN TAKSONOMI BLOOM</strong></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Setelah pengetahuan berhasil distrukturkan dari daftar ide menjadi peta yang kohesif (Bab 1), tantangan berikutnya adalah memetakan kedalaman pemahaman—seberapa dalam sistem, baik manusia maupun cerdas, memproses informasi tersebut. Bab ini menggunakan <strong>Taksonomi Bloom</strong> sebagai kerangka kerja untuk menilai kedalaman kognitif yang diperlukan untuk rekayasa sistem cerdas adaptif.</p>
<section id="taksonomi-bloom-enam-tingkat-kedalaman-kognitif" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="taksonomi-bloom-enam-tingkat-kedalaman-kognitif"><span class="header-section-number">3.1</span> 2.1 Taksonomi Bloom: Enam Tingkat Kedalaman Kognitif</h2>
<p><strong>Taksonomi Bloom</strong> adalah kerangka penting yang mengkategorikan keterampilan kognitif menjadi enam tingkat yang berbeda, bergerak dari pemikiran tingkat rendah (LOTS) ke pemikiran tingkat tinggi (HOTS). Dalam konteks rekayasa sistem cerdas, sistem yang benar-benar cerdas harus mampu mencapai tingkat kognitif tertinggi, yaitu Mencipta dan Mengevaluasi.</p>
<p>Enam tingkatan tersebut didefinisikan sebagai:</p>
<ol type="1">
<li><strong>Mengingat (<em>Remembering</em>):</strong> Kemampuan untuk mengingat kembali fakta dan konsep dasar.</li>
<li><strong>Memahami (<em>Understanding</em>):</strong> Kemampuan untuk menjelaskan ide atau konsep.</li>
<li><strong>Mengaplikasikan (<em>Applying</em>):</strong> Kemampuan untuk menggunakan informasi yang dimiliki dalam situasi baru.</li>
<li><strong>Menganalisis (<em>Analyzing</em>):</strong> Kemampuan untuk menarik hubungan di antara ide-ide yang berbeda, mencari pola, dan menentukan sebab-akibat.</li>
<li><strong>Mengevaluasi (<em>Evaluating</em>):</strong> Kemampuan untuk membenarkan suatu keputusan atau arah tindakan, dengan mempertimbangkan kualitas dan validitas.</li>
<li><strong>Mencipta (<em>Creating</em>):</strong> Kemampuan untuk menghasilkan karya baru atau orisinal, atau merumuskan model/hipotesis baru.</li>
</ol>
</section>
<section id="struktur-peta-untuk-merepresentasikan-kedalaman" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="struktur-peta-untuk-merepresentasikan-kedalaman"><span class="header-section-number">3.2</span> 2.2 Struktur Peta untuk Merepresentasikan Kedalaman</h2>
<p>Untuk merepresentasikan keenam tingkat kognitif ini dalam bentuk peta pengetahuan, peta pikiran radial sederhana tidak memadai karena cenderung meratakan informasi menjadi satu lapisan kepentingan.</p>
<p>Jenis peta spesifik yang paling efektif untuk merefleksikan Taksonomi Bloom adalah <strong>Peta Konsep Hierarkis</strong> (atau <em>Layered Knowledge Graph</em>). Struktur ini diorganisasikan secara vertikal atau konsentris, memungkinkan representasi kedalaman secara visual. Peta harus bergerak dari fakta konkret di bagian bawah (atau pusat) menuju koneksi abstrak dan kreasi di bagian atas (atau tepi luar).</p>
<p>Peta Konsep Hierarkis secara khusus dipilih karena memungkinkan pergerakan logis dari fakta dasar ke kreasi abstrak, dengan setiap langkah kedalaman kognitif dicerminkan oleh fitur pemetaan yang semakin kompleks.</p>
<p><strong>Usulan Gambar 2.1: Representasi Taksonomi Bloom dalam Bentuk Piramida Kognitif</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Placeholder Gambar</th>
<th style="text-align: left;">Caption</th>
<th style="text-align: left;">Sumber</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Gambar 2.1</strong></td>
<td style="text-align: left;">Diagram piramida (atau kerucut) yang menampilkan enam tingkat Taksonomi Bloom, mulai dari basis “Mengingat” hingga puncak “Mencipta”, untuk menggambarkan kedalaman pemrosesan kognitif yang diperlukan dalam sistem cerdas.</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</section>
<section id="menerjemahkan-tingkat-kognitif-menjadi-elemen-peta" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="menerjemahkan-tingkat-kognitif-menjadi-elemen-peta"><span class="header-section-number">3.3</span> 2.3 Menerjemahkan Tingkat Kognitif menjadi Elemen Peta</h2>
<p>Transformasi peta statis menjadi mesin logika yang dapat dieksekusi terjadi ketika elemen-elemen peta diterjemahkan sesuai dengan kedalaman kognitif Taksonomi Bloom.</p>
<p><strong>Tabel 2.1: Pemetaan Tingkat Kognitif Bloom ke Elemen Pemetaan Pengetahuan</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Tingkat Bloom</th>
<th style="text-align: left;">Fungsi Kognitif</th>
<th style="text-align: left;">Elemen Peta (Aksi Pemetaan)</th>
<th style="text-align: left;">Contoh Elemen Peta</th>
<th style="text-align: left;">Sumber</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>1. Mengingat</strong></td>
<td style="text-align: left;">Mengingat fakta dasar.</td>
<td style="text-align: left;"><strong>Node Terisolasi/Titik Data</strong></td>
<td style="text-align: left;">Kata tunggal, definisi, atau fakta yang ditempatkan di pusat atau dasar peta.</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>2. Memahami</strong></td>
<td style="text-align: left;">Menjelaskan konsep dan konteks.</td>
<td style="text-align: left;"><strong>Koneksi Berlabel (Proposisi)</strong></td>
<td style="text-align: left;">Garis pendek yang menghubungkan Node Level 1, harus diberi label untuk menjelaskan hubungan (misalnya, <em>berinteraksi untuk menentukan harga</em>).</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>3. Mengaplikasikan</strong></td>
<td style="text-align: left;">Menggunakan informasi dalam situasi baru.</td>
<td style="text-align: left;"><strong>Pengelompokan/Kluster</strong></td>
<td style="text-align: left;">Batas visual yang mengelilingi sekelompok <em>node</em> untuk menunjukkan konteks penggunaan tertentu (misalnya, <em>Mekanisme Pasar</em>).</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>4. Menganalisis</strong></td>
<td style="text-align: left;">Menarik hubungan dan pola antar ide.</td>
<td style="text-align: left;"><strong>Tautan Silang (<em>Cross-Links</em>)</strong></td>
<td style="text-align: left;">Garis putus-putus atau berbeda warna yang memotong hierarki, menghubungkan cabang peta yang berbeda dan tampaknya tidak terkait.</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>5. Mengevaluasi</strong></td>
<td style="text-align: left;">Menilai kualitas, validitas, dan nilai.</td>
<td style="text-align: left;"><strong>Anotasi Visual</strong></td>
<td style="text-align: left;">Penanda visual seperti kode warna atau ikon (<em>sticky note</em>) yang digunakan untuk menunjukkan kritik, kontradiksi, atau penilaian (<em>Contested Theory</em>).</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>6. Mencipta</strong></td>
<td style="text-align: left;">Menghasilkan model atau hipotesis baru.</td>
<td style="text-align: left;"><strong>Cabang Baru/Restrukturisasi</strong></td>
<td style="text-align: left;">Bagian peta yang sama sekali baru, menyusun ulang elemen yang ada dengan cara yang orisinal untuk mengusulkan model baru (misalnya, <em>Ekonomi Berkelanjutan</em>).</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<p>Tautan silang (Level 4, Menganalisis) mewakili pemahaman mendalam karena memecah hierarki linier. Peta yang hanya mengandung kata-kata adalah peta Mengingat, tetapi peta yang mengandung tautan berlabel yang menghubungkan konsep jauh adalah peta Menganalisis dan Mencipta.</p>
</section>
<section id="metafora-visual-untuk-kedalaman-pohon-pengetahuan-dan-bawang" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="metafora-visual-untuk-kedalaman-pohon-pengetahuan-dan-bawang"><span class="header-section-number">3.4</span> 2.4 Metafora Visual untuk Kedalaman: Pohon Pengetahuan dan Bawang</h2>
<p>Untuk lebih memahami representasi kedalaman kognitif pada peta, dua metafora visual dapat digunakan: Pohon Pengetahuan dan Bawang.</p>
<section id="a.-pohon-pengetahuan-hierarki-vertikal" class="level3" data-number="3.4.1">
<h3 data-number="3.4.1" class="anchored" data-anchor-id="a.-pohon-pengetahuan-hierarki-vertikal"><span class="header-section-number">3.4.1</span> A. Pohon Pengetahuan (Hierarki Vertikal)</h3>
<p>Peta ini memvisualisasikan pengetahuan sebagai entitas organik dengan hierarki vertikal: * <strong>Akar</strong> merepresentasikan fakta atau data (Mengingat). * <strong>Batang</strong> merepresentasikan konsep utama (Memahami). * <strong>Cabang</strong> merepresentasikan aplikasi konsep (Mengaplikasikan). * <strong>Penyerbukan Silang</strong> (Sistem sulur) menghubungkan cabang yang berbeda, melambangkan <strong>Menganalisis</strong>. * <strong>Buah</strong> yang dihasilkan merepresentasikan ide-ide baru (Mencipta).</p>
</section>
<section id="b.-bawang-peta-konsentris" class="level3" data-number="3.4.2">
<h3 data-number="3.4.2" class="anchored" data-anchor-id="b.-bawang-peta-konsentris"><span class="header-section-number">3.4.2</span> B. Bawang (Peta Konsentris)</h3>
<p>Metafora ini sangat sesuai untuk sistem cerdas atau sistem yang dapat ditransfer (<em>transferable knowledge systems</em>) karena menekankan lapisan pemikiran. Kedalaman meningkat saat bergerak dari luar ke pusat: * <strong>Inti Tengah</strong> berisi definisi kunci (Mengingat). * <strong>Cincin Pertama</strong> berisi hubungan dan proses (Memahami). * <strong>Cincin Kedua</strong> berisi konteks aplikasi (Mengaplikasikan). * <strong>Cincin Luar</strong> berisi tautan ke sistem eksternal (Menganalisis/Mengevaluasi).</p>
<p><strong>Usulan Gambar 2.2: Dualitas Metafora Visual untuk Kedalaman Kognitif</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Placeholder Gambar</th>
<th style="text-align: left;">Caption</th>
<th style="text-align: left;">Sumber</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Gambar 2.2</strong></td>
<td style="text-align: left;">Diagram berdampingan yang menunjukkan (A) Metafora Pohon Pengetahuan (dengan Akar, Batang, Cabang, dan Buah) dan (B) Metafora Bawang (dengan lapisan konsentris), keduanya berlabel dengan tingkat Taksonomi Bloom untuk memvisualisasikan bagaimana kedalaman kognitif direpresentasikan dalam arsitektur peta.</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<p>Melalui pemetaan yang ketat berdasarkan Taksonomi Bloom, peta pengetahuan bergerak melampaui sekadar menunjukkan <em>apa</em> yang diketahui, menjadi representasi yang dapat mengukur <em>seberapa dalam</em> sistem memahami, yang merupakan prasyarat penting sebelum kita dapat memetakan tindakan.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>